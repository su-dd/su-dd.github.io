<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[进程管理]]></title>
    <url>%2F2019%2F02%2F26%2F%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[处理机 是计算机系统的 核心资源 ；现在的处理器速度越来越快，充分的利用处理器可以大大的提高系统效率。操作系统中的并发管理和控制是基于处理器管理下实现的。 进程 是系统并发执行的体现，是分配资源的基本单位，是独立运行的基本单位。 进程是处理机管理中最基本、最重要的概念；因此，处理机管理也被称为进程管理。 处理机管理的功能就是组织和协调用户对处理机的争夺使用，把处理机分配给进程，对进程进行管理和控制，最大限度也发挥处理机的作用。 并行并行是程序发展中的产物 表现： 1、资源共享。为了提高资源的利用率，计算机系统中的资源不再由一道程序专用，是多道程序共同使用。 2、程序的并发执行或并行执行。 逻辑上： 1、允许多道不同用户的程序并行运行；2、允许一个用户程序内部完成不同操作的程序段之间并行运行；3、允许操作系统内部不同的程序之间并行运行。 物理上： 1、内存储器中保存多个程序， I/O 设备被多个程序交替地共享使用；2、在多处理机系统的情形下，表现为多个程序在各自的处理机上运行，执行时间是重叠的。3、单处理机系统时，程序的执行表现为多道程序交替地在处理机上相互空插运行。 进程的状态转换]]></content>
      <categories>
        <category>系统工程师考试归纳进程管理</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统的定义]]></title>
    <url>%2F2019%2F02%2F26%2F%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[操作系统计算机系统由 硬件 和 软件 两个部分组成。 操作系统（Operating System， OS）&emsp;&emsp;计算机系统中的核心系统软件，负责管理和控制计算机系统中的硬件和软件资源，合理地组织计算机工作流程和有效地利用资源，在计算机与用户之间起接口的作用。 操作系统是计算机系统中最基本的软件： 管理计算机系统的软、硬件资源。 控制程序的执行。 操作系统管理的对象： 处理器、存储器、文件、设备、作业。 操作系统的主要功能是进行 处理机与进程管理、存储管理、设备管理、文件管理、 作业管理 的工作。 分类： 批处理操作系统 分时操作系统 实时操作系统 网络操作系统 分布式操作系统 嵌入式操作系统 微内核操作系统 等等.. 操作系统为用户提供的接口： 命令、菜单、窗口之类 操作系统为应用程序提供的接口： API]]></content>
      <categories>
        <category>系统工程师考试归纳</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>操作系统的定义</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[流水线]]></title>
    <url>%2F2019%2F02%2F21%2F%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%2F%E6%B5%81%E6%B0%B4%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[流水线原理：计算机的任务中，存在大量相同任务的执行。把一个任务分解为若干顺序执行的子任务，不同的子任务由不同的执行机构负责执行，而这些机构可以同时并行工作。在任一时刻，任一任务只占用其中一个执行机构，这样就可以实现多个任务的重叠执行，以提高工作效率。 流水线周期流水线过程分为N个阶段，最耗时的那段为流水线周期。 流水线执行时间计算 1 个任务的执行过程可分成 N 个阶段，假设每个阶段完成时间为 t，则完成该任务所需的时间即为 Nt。若以传统的方式，则完成 k 个任务所需的时间是 kNt；而使用流水线技术执行，且花费的时间是 Nt+(k-1)t。也就是说，除了第 1 个任务需要完整的时间外，其他都通过并行，节省下了大量的时间。 执行时间理论值： 流水线执行时间 = 一条指令执行的时间 +（总任务数-1）× 流水线周期 在实际中，真正做流水线处理时，考虑到处理的复杂性，会将指令的每个执行阶段的时间都统一为流水线周期。 执行时间实际值： 流水线执行时间 = 拆分的子任务数 × 流水线周期 +（总任务数-1）× 流水线周期 流水线吞吐率流水线的吞吐率（Though Put rate， TP）是指在单位时间内流水线所完成的任务数量或输出的结果数量。 基本公式： TP = \frac{n}{T_k}n 为任务数，Tk 为处理完 n 个任务用的时间。 TP_{max} = \lim_{n \to \infty} \frac{n}{(k + n - 1)t} = \frac{1}{t}t 位平均时间。 流水线加速比在流水线中，因为在同一时刻，有多个任务在重叠地执行，虽然完成一个任务的时间与单独执行该任务相近（甚至由于分段的缘故，可能更多一些），但是从整体上看完成多个任务所需的时间则大大减少。 完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比称为流水线的加速比（speedup ratio）。 如果不使用流水线，即顺序执行所用的时间为 T0 ，使用流水线的执行时间为 Tk ，则计算流水线加速比的基本公式如下： S = \frac{T_o}{T_k}如果流水线各个流水段的执行时间都相等（设为 Dt ），则一条 k 段流水线完成 n 个连 续任务所需要的时间为 (k+n-1)Dt 。如果不使用流水线，即顺序执行这 n 个任务，则所需要的时间为 nkDt 。因此，各个流水段执行时间均相等的一条 k 段流水线完成 n 个连续任务 时的实际加速比为 : t 位平均时间: S = \frac{nkt}{(k+n-1)t} = \frac{nk}{k+n-1}则最大加速比： S_{max} = \lim_{n \to \infty} \frac{nk}{k+n-1} = k]]></content>
      <categories>
        <category>系统工程师考试归纳</category>
      </categories>
      <tags>
        <tag>计算机原理</tag>
        <tag>流水线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[存储器]]></title>
    <url>%2F2019%2F02%2F20%2F%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%2F%E5%AD%98%E5%82%A8%E5%99%A8%2F</url>
    <content type="text"><![CDATA[存取器系统定义 存储器：用于存放程序和数据的部件，是一个记忆装置，是计算机实现“存储程序控制”的基础。 规模较大的存储器往往分成若干级，称为存储器系统。局部性原理程序在执行时呈现出局部性规律，即在一较短的时间内，程序的执行仅局限于某个部分。相应地，它所访问的存储空间也仅局限于某个区域。程序局部性包括时间局部性和空间局部性。时间局部性： 指程序中的某条指令一旦执行，不久以后该指令可能再次执行。产生时间局部性的典型原因是由于程序中存在着大量的循环操作；空间局部性： 指一旦程序访问了某个存储单元，不久以后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址可能集中在一定的范围内，其典型情况是程序顺序执行。 分类 对应硬件 存取方式 容量 读取速度 分类 CAM 相联存取 小 快 Cache SRAM 随机存取 小 快 主存（主存储器） DRAM 随机存取 小 快 主存（主存储器） ROM 随机存取 小 快 主存（主存储器） 硬盘 直接存取 大 慢 辅存（辅助存储器） 磁带 顺序存取 大 慢 辅存（辅助存储器） P.S. 特殊说明 Cache的存在是为了解决主存和CPU速度不匹配；用于快速提供指令和数据。 RAM（Random Access Memory ）分为 DRAM（Dynamic RAM）和SRAM（Static RAM）； ROM是RAM的特殊形式，只能随机读出而不能写入 ；断点内容不会丢失，信息一旦写入不可修改。 DRAM &amp; SRAMDRAM： 信息会随时间逐渐消失，因此需要定时对其进行刷新维持信息不丢失。SRAM： 在不断电的情况下信息能够一直保持而不会丢失。 比较： 标题 密度 速度 价格 DRAM 大 慢 低 SRAM 小 快（不需要刷星电路） 高 内存编址定义内存编址：​ 存储器由一块块的空间（存储单元）组成，为了方便寻找到每一块空间，我们需要对每一个空间进行标识。芯片：​ 存储器由若干个芯片构成，一个芯片中有若干个存储单位。存储器容量 = 芯片容量 × 芯片个数芯片容量 = 一个地址的容量 × 编址总数 编址方式字编址：同数据总线长度，一般为32bit，64bit。 字节编址：一字节为8bit。 比特比特为bit，是一个正负单位。 磁带一种顺序存取的设备，其特点包括：存取时间较长，但存储容量大，便于携带，价格便宜。磁带应用的场景越来越少，目前主要用于资料的归档保存。 硬盘硬盘存储器的信息分布层次为：记录面，圆柱面，磁道，扇区。每个盘片有两个记录面，每个记录面对应一个磁头。所以记录面号就是磁头号。最外圈磁道为0号，往内依次增加。通常将一条磁道划分为若干个段，每个段称为一个扇区或扇段，每个扇区存放一个定长信息块（例如， 512 个字节） ；扇区的编号从1开始。 每个磁盘片有 m 个磁道，则该硬盘共有 m 个柱面 。 大文件存储策略引入柱面概念是为了提高硬盘的存储速度。 当主机要存入一个较大的文件时，若一条磁道存不完，就需要存放在几条磁道上。这时，应首先将一个文件尽可能地存放在同一柱面中。如果仍存放不完，再存入相邻的柱面内。 存取时间寻道：在磁盘上进行信息的读写时，首先需要定位到目标磁道，这个过程称之为寻道； 寻道时间：寻道所消耗的时间称 ； 旋转延时：定位到目标磁道后，需要定位到目标扇区，此过程通过旋转盘片完成，平均旋转半圈可到目标位置 ； 公式：磁盘访问时间（存取时间） = 寻道时间 + 旋转延迟时间 Cache大多数 RISC 采用了 Cache 方案，使用 Cache 来提高取指令的速度。而且，有的 RISC使用两个独立的 Cache 来改善性能。一个称为指令 Cache，另一个称为数据 Cache。这样，取指令和取数据可以同时进行，互不干扰。 CAM相联存储器（ContentAddressable Memory， CAM），一种基于数据内容进行访问的存储设备。当对其写入数据时， CAM 能够自动选择一个未用的空单元进行存储；当要读出数据时，不是给出其存储单元的地址，而是直接给出该数据或者该数据的一部分内容， CAM 对所有存储单元中的数据同时进行比较，并标记符合条件的所有数据以供读取。由于比较是同时、并行进行的，所以，这种基于数据内容进行读写的机制，其速度比基于地址进行读写的方式要快很多。 Cache命中率以 h 代表对 Cache 的访问命中率（“1-h”称为失效率，或者称为未命中率）t1 表示 cache 的周期时间t2 表示内存的周期时间，以读操作为例，使用“ Cache+主存储器”的系统的平均周期为 t3。则：t3 =t1′ h+t2′ (1-h) 映射机制当 CPU 发出访存请求后，存储器地址先被送到 Cache 控制器以确定所需数据是否已在 Cache 中，若命中则直接对 Cache 进行访问。这个过程称为 Cache 的地址映射（映像）。在 Cache 的地址映射中，主存和 Cache 将均分成容量相同的块（页）。 例：映像条件内存容量为 1GB， Cache 容量为 8MB，页面的大小为 512KB。 直接映像主存地址被分成三个部分：区号、页号、页内地址；直接映像中，先分区，再分页。一个区的大小就是 Cache 容量的大小，所以一共分：1GB/8MB=128 个区，区号 7 位。 每个区分： 8MB/512KB=16 个页，所以页号为 4 位。 每个主存页只能复制到某一固定的 Cache 页中；直接映像方式的映像规律是： 主存中每个区的第 0 页，只能进入到 Cache 的第 0 页。即：若当前时刻 Cache 中 0 号页已被占据，而 1-15 号页空闲，现在要将 1 区第 0 页（即内存的 16 页）调入 Cache 是会发生冲突的。所以直接映像的块冲突率非常高。 优点 ：比较容易实现缺点 ：不够灵活，有可能使 Cache 的存储空间得不到充分利用。 全相联映像主存地址分为两个部分，分别为地址部分（主存页标记）和数据部分（页内地址）。数据部分用于存放数据，而地址部分则存放该数据的存储器地址。 每个 Cache 页可映像到 2048 个主存页中的任一页，所以每页的Cache 标记也需要 11 位，以表明它现在所映像的主存页号。因此， Cache 标记信息位数增加，比较逻辑成本随之增加。 在全相联映像方式中，主存地址不能直接提取 Cache 页号，而是需要将主存页标记与Cache 各页的标记逐个比较，直到找到标记符合的页（访问 Cache 命中），或者全部比较完后仍无符合的标记（访问 Cache 失败）。因此这种映像方式速度很慢，失掉了高速缓存的作用，这是全相联映像方式的最大缺点。如果让主存页标记与各 Cache 标记同时比较，则成本又太高。全相联映像方式因比较器电路难于设计和实现，只适用于小容量 Cache。 组相联映像组相联映像（页组映像）介于直接映像和全相联映像之间，是这两种映像的一种折衷方案。全相联映像方式以页为单位，可自由映像，没有固定的对应关系。直接映像方式中，主存分组，主存组内的各页与 Cache 的页之间采取的是固定的映像关系，但各组均可映像到Cache 中。在组相联映像方式中，主存与 Cache 都分组，主存中一个组内的页数与 Cache 的分组数相同； 例中：主存分 128 个区，每个区 8 个组，每个组 2 个页。组相联映像方式的主存地址组织： 组相联映像的规则是：主存中的组与 Cache 的组形成直接映像关系，而每个组内的页是全相联映像关系。如主存 1 区 0 页，他在 0 组中，所以只能进入 Cache 的 0 组中，至于进入到 Cache 的 0 组 0 页，还是 0 组 1 页，并无强制要求，可任意放置。 在组相联映像中， Cache 中每一页的标记位长度为 8 位，因为此时除了要记录区号，还得记录组号，即区号 7 位加组号 1 位等于 8 位。 容易看出，如果 Cache 中每组只有一页，则组相联映像方式就变成了直接映像方式。如果 Cache 中每组页数为 16 页（即 Cache 只分一组），则就是全相联映像。因此，在具体设计组相联映像时，可以根据设计目标选取某一折衷值。 在组相联映像中，由于 Cache 中每组有若干可供选择的页，因而它在映像定位方面较直接映像方式灵活； 每组页数有限，因此付出的代价不是很大，可以根据设计目标选择组内页数。 替换算法当 Cache 产生了一次访问未命中之后，相应的数据应同时读入 CPU 和 Cache。但是当Cache 已存满数据后，新数据必须替换（淘汰） Cache 中的某些旧数据。最常用的替换算法有以下三种： （1）随机算法。这是最简单的替换算法。随机法完全不管 Cache 块过去、现在及将来的使用情况，简单地根据一个随机数，选择一块替换掉。 （2）先进先出（First In and First Out， FIFO）算法。按调入 Cache 的先后决定淘汰的顺序，即在需要更新时，将最先进入 Cache 的块作为被替换的块。这种方法要求为每块做一记录，记下它们进入 ache 的先后次序。这种方法容易实现，而且系统开销小。其缺点是可能会把一些需要经常使用的程序块（如循环程序）替换掉。 （3）近期最少使用（Least Recently Used， LRU）算法。 LRU 算法是把 CPU 近期最少使用的块作为被替换的块。这种替换方法需要随时记录 Cache 中各块的使用情况，以便确定哪个块是近期最少使用的块。 LRU 算法相对合理，但实现起来比较复杂，系统开销较大。通常需要对每一块设置一个称为“年龄计数器”的硬件或软件计数器，用以记录其被使用的情况。 写操作因为需要保证缓存在 Cache 中的数据与内存中的内容一致，相对读操作而言， Cache 的写操作比较复杂，常用的有以下几种方法。 （1）写直达（write through）。当要写 Cache 时，数据同时写回内存，有时也称为写通。当某一块需要替换时，也不必把这一块写回到主存中去，新调入的块可以立即把这一块覆盖掉。这种方法实现简单，而且能随时保持主存数据的正确性，但可能增加多次不必要的主存写入，会降低存取速度。 （2）写回（write back）。 CPU 修改 Cache 的某一块后，相应的数据并不立即写入内存单元，而是当该块从 cache 中被淘汰时，才把数据写回到内存中。在采用这种更新策略的cache 块表中，一般有一个标志位，当一块中的任何一个单元被修改时，标志位被置“1”。在需要替换掉这一块时，如果标志位为“1”，则必须先把这一块写回到主存中去之后，才能再调入新的块；如果标志位为“0”，则这一块不必写回主存，只要用新调入的块覆盖掉这一块即可。这种方法的优点是操作速度快，缺点是因主存中的字块未随时修改而有可能出错。 （3）标记法。对 Cache 中的每一个数据设置一个有效位。当数据进入 Cache 后，有效位置“1”；而当 CPU 要对该数据进行修改时，数据只需写入内存并同时将该有效位置“0”。当要从 Cache 中读取数据时需要测试其有效位，若为“l”则直接从 Cache 中取数，否则，从内存中取数。]]></content>
      <categories>
        <category>系统工程师考试归纳</category>
      </categories>
      <tags>
        <tag>计算机原理</tag>
        <tag>存储器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QMetaObject文档[翻译]]]></title>
    <url>%2F2019%2F02%2F20%2FQt%2FQt%E6%96%87%E6%A1%A3%2FQMetaObject%E6%96%87%E6%A1%A3-%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"><![CDATA[QMetaObject ClassThe QMetaObject class contains meta-information about Qt objects. More…元对象类储存Qt对象的元信息。 Header : #include qmake : QT += core Public Typesclass Connection Public Functions1234567891011121314151617181920212223242526QMetaClassInfo classInfo(int index) constint classInfoCount() constint classInfoOffset() constconst char * className() constQMetaMethod constructor(int index) constint constructorCount() constQMetaEnum enumerator(int index) constint enumeratorCount() constint enumeratorOffset() constint indexOfClassInfo(const char *name) constint indexOfConstructor(const char *constructor) constint indexOfEnumerator(const char *name) constint indexOfMethod(const char *method) constint indexOfProperty(const char *name) constint indexOfSignal(const char *signal) constint indexOfSlot(const char *slot) constbool inherits(const QMetaObject *metaObject) constQMetaMethod method(int index) constint methodCount() constint methodOffset() constQObject * newInstance(QGenericArgument val0 = QGenericArgument( Q_NULLPTR ), QGenericArgument val1 = QGenericArgument(), QGenericArgument val2 = QGenericArgument(), QGenericArgument val3 = QGenericArgument(), QGenericArgument val4 = QGenericArgument(), QGenericArgument val5 = QGenericArgument(), QGenericArgument val6 = QGenericArgument(), QGenericArgument val7 = QGenericArgument(), QGenericArgument val8 = QGenericArgument(), QGenericArgument val9 = QGenericArgument()) constQMetaProperty property(int index) constint propertyCount() constint propertyOffset() constconst QMetaObject* superClass() constQMetaProperty userProperty() const Static Public Members12345678910111213bool checkConnectArgs(const char *signal, const char *method)bool checkConnectArgs(const QMetaMethod &amp;signal, const QMetaMethod &amp;method)void connectSlotsByName(QObject *object)bool invokeMethod(QObject *obj, const char *member, Qt::ConnectionType type, QGenericReturnArgument ret, QGenericArgument val0 = QGenericArgument( Q_NULLPTR ), QGenericArgument val1 = QGenericArgument(), QGenericArgument val2 = QGenericArgument(), QGenericArgument val3 = QGenericArgument(), QGenericArgument val4 = QGenericArgument(), QGenericArgument val5 = QGenericArgument(), QGenericArgument val6 = QGenericArgument(), QGenericArgument val7 = QGenericArgument(), QGenericArgument val8 = QGenericArgument(), QGenericArgument val9 = QGenericArgument())bool invokeMethod(QObject *obj, const char *member, QGenericReturnArgument ret, QGenericArgument val0 = QGenericArgument( Q_NULLPTR ), QGenericArgument val1 = QGenericArgument(), QGenericArgument val2 = QGenericArgument(), QGenericArgument val3 = QGenericArgument(), QGenericArgument val4 = QGenericArgument(), QGenericArgument val5 = QGenericArgument(), QGenericArgument val6 = QGenericArgument(), QGenericArgument val7 = QGenericArgument(), QGenericArgument val8 = QGenericArgument(), QGenericArgument val9 = QGenericArgument())bool invokeMethod(QObject *obj, const char *member, Qt::ConnectionType type, QGenericArgument val0 = QGenericArgument( Q_NULLPTR ), QGenericArgument val1 = QGenericArgument(), QGenericArgument val2 = QGenericArgument(), QGenericArgument val3 = QGenericArgument(), QGenericArgument val4 = QGenericArgument(), QGenericArgument val5 = QGenericArgument(), QGenericArgument val6 = QGenericArgument(), QGenericArgument val7 = QGenericArgument(), QGenericArgument val8 = QGenericArgument(), QGenericArgument val9 = QGenericArgument())bool invokeMethod(QObject *obj, const char *member, QGenericArgument val0 = QGenericArgument( Q_NULLPTR ), QGenericArgument val1 = QGenericArgument(), QGenericArgument val2 = QGenericArgument(), QGenericArgument val3 = QGenericArgument(), QGenericArgument val4 = QGenericArgument(), QGenericArgument val5 = QGenericArgument(), QGenericArgument val6 = QGenericArgument(), QGenericArgument val7 = QGenericArgument(), QGenericArgument val8 = QGenericArgument(), QGenericArgument val9 = QGenericArgument())bool invokeMethod(QObject *receiver, PointerToMemberFunction function, Qt::ConnectionType type = Qt::AutoConnection, MemberFunctionReturnType *ret = nullptr)bool invokeMethod(QObject *receiver, PointerToMemberFunction function, MemberFunctionReturnType *ret)bool invokeMethod(QObject *context, Functor function, Qt::ConnectionType type = Qt::AutoConnection, FunctorReturnType *ret = nullptr)bool invokeMethod(QObject *context, Functor function, FunctorReturnType *ret)QByteArray normalizedSignature(const char *method)QByteArray normalizedType(const char *type) Macros12QGenericArgument Q_ARG(Type, const Type &amp;value)QGenericReturnArgument Q_RETURN_ARG(Type, Type &amp;value) Detailed Description The QMetaObject class contains meta-information about Qt objects. 元对象类储存Qt对象的元信息。 The Qt Meta-Object System in Qt is responsible for the signals and slots inter-object communication mechanism, runtime type information, and the Qt property system. A single QMetaObject instance is created for each QObject subclass that is used in an application, and this instance stores all the meta-information for the QObject subclass. This object is available as QObject::metaObject(). Qt中的Qt元对象系统负责对象间交流机制（信号和槽）、运行时态信息和qt属性系统。每一个QObject子对象在应用中使用时都会创建一个单例QMetaObject实例，实例储存QObject子对象的所有元信息。实例可以通过QObject::metaObject()获得。 This class is not normally required for application programming, but it is useful if you write meta-applications, such as scripting engines or GUI builders. 这个类在一般编程中是必须的，但是在元应用程序是需要的，如脚本引擎和GUI构建器。 The functions you are most likely to find useful are these: 函数中，你最可能发现有用的是： className() returns the name of a class. superClass() returns the superclass’s meta-object. method() and methodCount() provide information about a class’s meta-methods (signals, slots and other invokable member functions). enumerator() and enumeratorCount() and provide information about a class’s enumerators. propertyCount() and property() provide information about a class’s properties. constructor() and constructorCount() provide information about a class’s meta-constructors. className() 返回类名。 superClass() 返回父类的元对象。 method() 和 methodCount() 提供类的元方法（信号、槽和其他可调用的成员函数）的信息。 enumerator() 和 enumeratorCount() 提供类的枚举成员的信息。 propertyCount() and property()提供类的属性信息。 constructor() and constructorCount()提供类的元构造器信息。 The index functions indexOfConstructor(), indexOfMethod(), indexOfEnumerator(), and indexOfProperty() map names of constructors, member functions, enumerators, or properties to indexes in the meta-object. For example, Qt uses indexOfMethod() internally when you connect a signal to a slot. 索引函数indexOfConstructor(), indexOfMethod(), indexOfEnumerator(), and indexOfProperty() 将构造函数、成员函数、枚举数或属性的名称映射到元对象中的索引中。例如，但你将一个信号关联到一个槽，Qt内部使用indexOfMethod()。 Classes can also have a list of name—value pairs of additional class information, stored in QMetaClassInfo objects. The number of pairs is returned by classInfoCount(), single pairs are returned by classInfo(), and you can search for pairs with indexOfClassInfo(). 类可以有一个额外的类信息的name—value键值对列表，存储在QMetaClassInfo对象中。键值对的数量等于classInfoCount()，单个键值对获取通过classInfo()获取，并且你可以通过indexOfClassInfo() 查找键值对。 See also QMetaClassInfo, QMetaEnum, QMetaMethod, QMetaProperty, QMetaType, and Meta-Object System. Member Function Documentation[static] bool QMetaObject::checkConnectArgs(const char signal, const char method) Returns true if the signal and method arguments are compatible; otherwise returns false. 如果信号和方法两个参数兼容，返回true，否则返回false。 Both signal and method are expected to be normalized. 信号和方法将被标准化。 See also normalizedSignature(). [static] bool QMetaObject::checkConnectArgs(const QMetaMethod &amp;signal, const QMetaMethod &amp;method) This is an overloaded function. 这是一个重载方法。 Returns true if the signal and method arguments are compatible; otherwise returns false. 如果信号和方法两个参数兼容，返回true，否则返回false。 This function was introduced in Qt 5.0. QMetaClassInfo QMetaObject::classInfo(int index) const Returns the meta-data for the item of class information with the given index. 根据具有给定索引，返回类信息项的元数据。 Example:123456789class MyClass : public QObject&#123; Q_OBJECT Q_CLASSINFO(&quot;author&quot;, &quot;Sabrina Schweinsteiger&quot;) Q_CLASSINFO(&quot;url&quot;, &quot;http://doc.moosesoft.co.uk/1.0/&quot;)public: ...&#125;; See also classInfoCount(), classInfoOffset(), and indexOfClassInfo(). int QMetaObject::classInfoCount() const Returns the number of items of class information in this class. 返回该类的类数据项的数量。 See also classInfo(), classInfoOffset(), and indexOfClassInfo(). int QMetaObject::classInfoOffset() const Returns the class information offset for this class; i.e. the index position of this class’s first class information item. 返回该类的类信息偏移量。即该类的第一个类信息项的索引位置。 If the class has no superclasses with class information, the offset is 0; otherwise the offset is the sum of all the class information items in the class’s superclasses. 如果该类的类信息中没有父类，偏移为0；否则偏移量是父类中类信息项的总和。 See also classInfo(), classInfoCount(), and indexOfClassInfo(). const char *QMetaObject::className() const Returns the class name. 返回类名。 See also superClass(). [static] void QMetaObject::connectSlotsByName(QObject *object) Searches recursively for all child objects of the given object, and connects matching signals from them to slots of object that follow the following form: 递归的查询给定的对象的所有子对象，并连接子对象中匹配的信号到符合以下形式的对象槽：1void on_&lt;object name&gt;_&lt;signal name&gt;(&lt;signal parameters&gt;); Let’s assume our object has a child object of type QPushButton with the object name button1. The slot to catch the button’s clicked() signal would be: 让我们假设我们的对象有一个QPushButton类型，对象名为button1的子对象。捕获该按钮的clicked()信号的槽是：1void on_button1_clicked(); If object itself has a properly set object name, its own signals are also connected to its respective slots. 如果对象本身有正确设置的对象名称，它自己的信号也被连接到它各自的槽。 See also QObject::setObjectName(). QMetaMethod QMetaObject::constructor(int index) const Returns the meta-data for the constructor with the given index. 根据给定的索引（index），返回构造器的元数据。 This function was introduced in Qt 4.5.See also constructorCount() and newInstance(). int QMetaObject::constructorCount() const Returns the number of constructors in this class. 返回该类中构造器的数量。 This function was introduced in Qt 4.5.See also constructor() and indexOfConstructor(). QMetaEnum QMetaObject::enumerator(int index) const Returns the meta-data for the enumerator with the given index. 根据给定的索引（index），返回枚举器的元数据。 See also enumeratorCount(), enumeratorOffset(), and indexOfEnumerator(). int QMetaObject::enumeratorCount() const Returns the number of enumerators in this class. 返回该类中枚举器的数量。 See also enumerator(), enumeratorOffset(), and indexOfEnumerator(). int QMetaObject::enumeratorOffset() constReturns the enumerator offset for this class; i.e. the index position of this class’s first enumerator. 返回该类中枚举器的偏移量；即该类中第一个构造器的索引位置。 If the class has no superclasses with enumerators, the offset is 0; otherwise the offset is the sum of all the enumerators in the class’s superclasses. 如果该类没有带有枚举器的父类，则偏移量为0；否则偏移量为所有父类中枚举器之和。 See also enumerator(), enumeratorCount(), and indexOfEnumerator(). int QMetaObject::indexOfClassInfo(const char *name) constFinds class information item name and returns its index; otherwise returns -1. 查找类信息项名称，返回它的索引；否则返回-1。 See also classInfo(), classInfoCount(), and classInfoOffset(). int QMetaObject::indexOfConstructor(const char *constructor) constFinds constructor and returns its index; otherwise returns -1. 查找类构造器返回它的索引；否则返回-1。 Note that the constructor has to be in normalized form, as returned by normalizedSignature(). 注意：构造函数必须是规范形式的，同normalizedSignature()返回值。 This function was introduced in Qt 4.5.See also constructor(), constructorCount(), and normalizedSignature(). int QMetaObject::indexOfEnumerator(const char *name) const Finds enumerator name and returns its index; otherwise returns -1. 查找枚举器名称，并返回索引；否则返回-1。 See also enumerator(), enumeratorCount(), and enumeratorOffset(). int QMetaObject::indexOfMethod(const char *method) constFinds method and returns its index; otherwise returns -1. 查找方法，返回索引；否则返回-1。 Note that the method has to be in normalized form, as returned by normalizedSignature(). 注意：函数必须是规范形式的，同normalizedSignature()返回值。 See also method(), methodCount(), methodOffset(), and normalizedSignature(). int QMetaObject::indexOfProperty(const char *name) constFinds property name and returns its index; otherwise returns -1. 查找属性，返回索引；否则返回-1。 See also property(), propertyCount(), and propertyOffset(). int QMetaObject::indexOfSignal(const char *signal) constFinds signal and returns its index; otherwise returns -1. 查找信号 ，返回索引；否则返回-1。 This is the same as indexOfMethod(), except that it will return -1 if the method exists but isn’t a signal. 这与indexOfMethod()相同，不同的是如果方法存在，但不是信号，返回-1。 Note that the signal has to be in normalized form, as returned by normalizedSignature(). 注意：信号必须是格式化的，同normalizedSignature()的返回值。 See also indexOfMethod(), normalizedSignature(), method(), methodCount(), and methodOffset(). int QMetaObject::indexOfSlot(const char *slot) constFinds slot and returns its index; otherwise returns -1. 查找信号 ，返回索引；否则返回-1。 This is the same as indexOfMethod(), except that it will return -1 if the method exists but isn’t a slot. 这与indexOfMethod()相同，不同的是如果方法存在，但不是槽，返回-1。 See also indexOfMethod(), method(), methodCount(), and methodOffset(). bool QMetaObject::inherits(const QMetaObject *metaObject) constReturns true if the class described by this QMetaObject inherits the type described by metaObject; otherwise returns false. 如果该类的QMetaObject继承于metaObject的类型，则返回true，否则返回false。 A type is considered to inherit itself. 一个类型被视为继承自身。 This function was introduced in Qt 5.7. [static] bool QMetaObject::invokeMethod(QObject obj, const char member, Qt::ConnectionType type, QGenericReturnArgument ret, QGenericArgument val0 = QGenericArgument( Q_NULLPTR ), QGenericArgument val1 = QGenericArgument(), QGenericArgument val2 = QGenericArgument(), QGenericArgument val3 = QGenericArgument(), QGenericArgument val4 = QGenericArgument(), QGenericArgument val5 = QGenericArgument(), QGenericArgument val6 = QGenericArgument(), QGenericArgument val7 = QGenericArgument(), QGenericArgument val8 = QGenericArgument(), QGenericArgument val9 = QGenericArgument())Invokes the member (a signal or a slot name) on the object obj. Returns true if the member could be invoked. Returns false if there is no such member or the parameters did not match. 调用 obj 上的成员函数（信号或槽）。如果函数（member）可以被调用返回true。如果没有这个函数或者参数不匹配返回false。 The invocation can be either synchronous or asynchronous, depending on type: 该调用可以时同步的，也可以时异步的。取决于类型：• If type is Qt::DirectConnection, the member will be invoked immediately.• 如果类型是直接连接（Qt::DirectConnection），函数将立刻被调用。• If type is Qt::QueuedConnection, a QEvent will be sent and the member is invoked as soon as the application enters the main event loop.• 如果类型是队列连接（Qt::QueuedConnection），一个Qt事件（QEvent）被发送，应用进入主事件循环则函数将立刻被调用。• If type is Qt::BlockingQueuedConnection, the method will be invoked in the same way as for Qt::QueuedConnection, except that the current thread will block until the event is delivered. Using this connection type to communicate between objects in the same thread will lead to deadlocks.• 如果类型是阻塞的队列连接（Qt::BlockingQueuedConnection），函数将被同队列连接（Qt::QueuedConnection）相同的方式调用，除非当前的线程将阻塞，直到事件被传递。用该连接类型连接同一个线程中的两个对象，将会导致死锁。• If type is Qt::AutoConnection, the member is invoked synchronously if obj lives in the same thread as the caller; otherwise it will invoke the member asynchronously.• 如果类型是阻塞的自动连接（Qt::AutoConnection），如果obj同调用者在同一个线程，函数将被同步调用；否则函数将被异步调用。 The return value of the member function call is placed in ret. If the invocation is asynchronous, the return value cannot be evaluated. You can pass up to ten arguments (val0, val1, val2, val3, val4, val5, val6, val7, val8, and val9) to the member function. 当前函数返回值放在 ret参数中。如果调用是异步调用，返回值不能估计。你可以将最多10个参数（val0, val1, val2, val3, val4, val5, val6, val7, val8, and val9）传递给成员函数。 QGenericArgument and QGenericReturnArgument are internal helper classes. Because signals and slots can be dynamically invoked, you must enclose the arguments using the Q_ARG() and Q_RETURN_ARG() macros. Q_ARG() takes a type name and a const reference of that type; Q_RETURN_ARG() takes a type name and a non-const reference. QGenericArgument和QGenericReturnArgument是内部的帮助类。因为信号和槽可以被动态的调用，你必须用Q_ARG()和Q_RETURN_ARG()宏把参数扩起来。Q_ARG()接受该类型的类型名称和Const引用；Q_RETURN_ARG()接受类型名称和非Const引用。 You only need to pass the name of the signal or slot to this function, not the entire signature. For example, to asynchronously invoke the quit() slot on a QThread, use the following code: 你只需要将信号和槽的名称传递给此函数，而不需要整个签名。例如，要异步调用Qt线程（QThread）的槽函数（quit()）。用以下代码：12QMetaObject::invokeMethod(thread, &quot;quit&quot;, Qt::QueuedConnection); With asynchronous method invocations, the parameters must be of types that are known to Qt’s meta-object system, because Qt needs to copy the arguments to store them in an event behind the scenes. If you try to use a queued connection and get the error message 对于异步方法的调用，因为Qt需要复制参数并将它们存储在幕后的事件中,参数必须是Qt的元对象系统知道的类型。如果你尝试使用排队连接并获得错误信息。 QMetaObject::invokeMethod: Unable to handle unregistered datatype ‘MyType’call qRegisterMetaType() to register the data type before you call invokeMethod(). 在你调用invokeMethod()之前，用qRegisterMetaType()注册数据类型 To synchronously invoke the compute(QString, int, double) slot on some arbitrary object obj retrieve its return value: 要同步调用某个任意对象obj的槽 compute(QString, int, double)，返回它的返回值：123456QString retVal;QMetaObject::invokeMethod(obj, &quot;compute&quot;, Qt::DirectConnection, Q_RETURN_ARG(QString, retVal), Q_ARG(QString, &quot;sqrt&quot;), Q_ARG(int, 42), Q_ARG(double, 9.7)); If the “compute” slot does not take exactly one QString, one int and one double in the specified order, the call will fail. 如果”compute” 槽按顺序接受一个QString，int和double，则调用失败。 See also Q_ARG(), Q_RETURN_ARG(), qRegisterMetaType(), and QMetaMethod::invoke(). [static] bool QMetaObject::invokeMethod(QObject obj, const char member, QGenericReturnArgument ret, QGenericArgument val0 = QGenericArgument( Q_NULLPTR ), QGenericArgument val1 = QGenericArgument(), QGenericArgument val2 = QGenericArgument(), QGenericArgument val3 = QGenericArgument(), QGenericArgument val4 = QGenericArgument(), QGenericArgument val5 = QGenericArgument(), QGenericArgument val6 = QGenericArgument(), QGenericArgument val7 = QGenericArgument(), QGenericArgument val8 = QGenericArgument(), QGenericArgument val9 = QGenericArgument()) This function overloads invokeMethod(). 改函数重载invokeMethod()。 This overload always invokes the member using the connection type Qt::AutoConnection. 该重载方式总是用Qt::AutoConnection的连接类型调用成员函数（member）。 [static] bool QMetaObject::invokeMethod(QObject obj, const char member, Qt::ConnectionType type, QGenericArgument val0 = QGenericArgument( Q_NULLPTR ), QGenericArgument val1 = QGenericArgument(), QGenericArgument val2 = QGenericArgument(), QGenericArgument val3 = QGenericArgument(), QGenericArgument val4 = QGenericArgument(), QGenericArgument val5 = QGenericArgument(), QGenericArgument val6 = QGenericArgument(), QGenericArgument val7 = QGenericArgument(), QGenericArgument val8 = QGenericArgument(), QGenericArgument val9 = QGenericArgument()) This function overloads invokeMethod(). 改函数重载invokeMethod()。 This overload can be used if the return value of the member is of no interest. 如果不需要返回值，使用该重载方式 [static] bool QMetaObject::invokeMethod(QObject obj, const char member, QGenericArgument val0 = QGenericArgument( Q_NULLPTR ), QGenericArgument val1 = QGenericArgument(), QGenericArgument val2 = QGenericArgument(), QGenericArgument val3 = QGenericArgument(), QGenericArgument val4 = QGenericArgument(), QGenericArgument val5 = QGenericArgument(), QGenericArgument val6 = QGenericArgument(), QGenericArgument val7 = QGenericArgument(), QGenericArgument val8 = QGenericArgument(), QGenericArgument val9 = QGenericArgument()) This function overloads invokeMethod(). 改函数重载invokeMethod()。 This overload invokes the member using the connection type Qt::AutoConnection and ignores return values. 该重载方式用Qt::AutoConnection的连接类型调用成员函数（member）并忽略返回值。 [static] bool QMetaObject::invokeMethod(QObject receiver, PointerToMemberFunction function, Qt::ConnectionType type = Qt::AutoConnection, MemberFunctionReturnType ret = nullptr) This is an overloaded function. 改函数重载invokeMethod()。 This function was introduced in Qt 5.10. [static] bool QMetaObject::invokeMethod(QObject receiver, PointerToMemberFunction function, MemberFunctionReturnType ret) This is an overloaded function. 改函数重载invokeMethod()。 This overload invokes the member function using the connection type Qt::AutoConnection. 该重载方式用Qt::AutoConnection的连接类型调用成员函数（function）。 This function was introduced in Qt 5.10. [static] bool QMetaObject::invokeMethod(QObject context, Functor function, Qt::ConnectionType type = Qt::AutoConnection, FunctorReturnType ret = nullptr) This is an overloaded function. 改函数重载invokeMethod()。 Call the functor in the event loop of context. 调用事件循环中的functor。（即function） This function was introduced in Qt 5.10. [static] bool QMetaObject::invokeMethod(QObject context, Functor function, FunctorReturnType ret)This is an overloaded function. 改函数重载invokeMethod()。 Call the functor in the event loop of context using the connection type Qt::AutoConnection. 用Qt::AutoConnection连接类型，调用事件循环中的functor。（即function） This function was introduced in Qt 5.10. QMetaMethod QMetaObject::method(int index) constReturns the meta-data for the method with the given index. 根据索引返回方法的元数据。 See also methodCount(), methodOffset(), and indexOfMethod(). int QMetaObject::methodCount() constReturns the number of methods in this class, including the number of methods provided by each base class. These include signals and slots as well as normal member functions. 返回该类中方法的总数，包括每一个基类提供的方法数。方法包括信号、槽和成员函数。 Use code like the following to obtain a QStringList containing the methods specific to a given class: 使用如下代码获得包含给定类的具体方法信息的QStringList ：1234const QMetaObject* metaObject = obj-&gt;metaObject();QStringList methods;for(int i = metaObject-&gt;methodOffset(); i &lt; metaObject-&gt;methodCount(); ++i) methods &lt;&lt; QString::fromLatin1(metaObject-&gt;method(i).methodSignature()); See also method(), methodOffset(), and indexOfMethod(). int QMetaObject::methodOffset() constReturns the method offset for this class; i.e. the index position of this class’s first member function. 返回该类的方法偏移量。即该类的第一个成员函数的索引位置。 The offset is the sum of all the methods in the class’s superclasses (which is always positive since QObject has the deleteLater() slot and a destroyed() signal). 这个偏移量是类的父类中所有方法的总和。（父类：继承于QObject有deleteLater() 槽和一个 destroyed()信息。） See also method(), methodCount(), and indexOfMethod(). QObject *QMetaObject::newInstance(QGenericArgument val0 = QGenericArgument( Q_NULLPTR ), QGenericArgument val1 = QGenericArgument(), QGenericArgument val2 = QGenericArgument(), QGenericArgument val3 = QGenericArgument(), QGenericArgument val4 = QGenericArgument(), QGenericArgument val5 = QGenericArgument(), QGenericArgument val6 = QGenericArgument(), QGenericArgument val7 = QGenericArgument(), QGenericArgument val8 = QGenericArgument(), QGenericArgument val9 = QGenericArgument()) const Constructs a new instance of this class. You can pass up to ten arguments (val0, val1, val2, val3, val4, val5, val6, val7, val8, and val9) to the constructor. Returns the new object, or 0 if no suitable constructor is available. 创建一个类的新对象。你可以传递10个参数(val0, val1, val2, val3, val4, val5, val6, val7, val8, and val9)到构造函数中。 Note that only constructors that are declared with the Q_INVOKABLE modifier are made available through the meta-object system. 注意：只有用Q_INVOKABLE 修饰的构造函数，能用元对象系统获得。 This function was introduced in Qt 4.5.See also Q_ARG() and constructor(). [static] QByteArray QMetaObject::normalizedSignature(const char *method)Normalizes the signature of the given method.规范化给定方法的签名。Qt uses normalized signatures to decide whether two given signals and slots are compatible. Normalization reduces whitespace to a minimum, moves ‘const’ to the front where appropriate, removes ‘const’ from value types and replaces const references with values.Qt使用规范化的签名决定两个给定信号和槽是否兼容。规范化将空白降到最小，在适当是时将“Const”移动到前面，从值类型中移除“Const”，并用值替换Const引用。See also checkConnectArgs() and normalizedType(). [static] QByteArray QMetaObject::normalizedType(const char *type)Normalizes a type. 规范化给定类型（type）。 See QMetaObject::normalizedSignature() for a description on how Qt normalizes. 关于Qt如何规范化，参见QMetaObject::normalizedSignature()描述。Example:12QByteArray normType = QMetaObject::normalizedType(&quot; int const *&quot;);// normType is now &quot;const int*&quot; This function was introduced in Qt 4.2.See also normalizedSignature(). QMetaProperty QMetaObject::property(int index) constReturns the meta-data for the property with the given index. If no such property exists, a null QMetaProperty is returned. 根据给定索引（index）返回属性的元数据。如果没有对应的属性存在，返回一个空QMetaProperty。 See also propertyCount(), propertyOffset(), and indexOfProperty(). int QMetaObject::propertyCount() const Returns the number of properties in this class, including the number of properties provided by each base class. 返回类中属性的数量，包括所有基类的属性的数量。 Use code like the following to obtain a QStringList containing the properties specific to a given class: 使用如下代码获得包含给定类的具体方法信息的QStringList ：1234const QMetaObject* metaObject = obj-&gt;metaObject();QStringList properties;for(int i = metaObject-&gt;propertyOffset(); i &lt; metaObject-&gt;propertyCount(); ++i) properties &lt;&lt; QString::fromLatin1(metaObject-&gt;property(i).name()); See also property(), propertyOffset(), and indexOfProperty(). int QMetaObject::propertyOffset() const Returns the property offset for this class; i.e. the index position of this class’s first property. 返回该类中属性偏移量；即该类中第一个属性的索引位置。 The offset is the sum of all the properties in the class’s superclasses (which is always positive since QObject has the name() property). 这个偏移量是类的父类中所有属性的总和。（父类：继承于QObject有name()属性。） See also property(), propertyCount(), and indexOfProperty(). const QMetaObject *QMetaObject::superClass() const Returns the meta-object of the superclass, or 0 if there is no such object. 返回超类的元对象，如果没有对应对象真返回0。 See also className(). QMetaProperty QMetaObject::userProperty() constReturns the property that has the USER flag set to true. 返回USER标志为true的属性。 This function was introduced in Qt 4.2.See also QMetaProperty::isUser(). Macro DocumentationQGenericArgument Q_ARG(Type, const Type &amp;value)This macro takes a Type and a value of that type and returns a QGenericArgument object that can be passed to QMetaObject::invokeMethod(). 该宏接受Type类型和Type类型的值，并且返回一个可以传给QMetaObject::invokeMethod()的QGenericArgument 对象。 See also Q_RETURN_ARG(). QGenericReturnArgument Q_RETURN_ARG(Type, Type &amp;value)This macro takes a Type and a non-const reference to a value of that type and returns a QGenericReturnArgument object that can be passed to QMetaObject::invokeMethod(). 该宏接受Type类型和Type类型的非Const引用值，并且返回一个可以传给QMetaObject::invokeMethod()的QGenericReturnArgument对象。 See also Q_ARG(). © 2017 The Qt Company Ltd. Documentation contributions included herein are the copyrights of their respective owners.The documentation provided herein is licensed under the terms of the GNU Free Documentation License version 1.3 as published by the Free Software Foundation.Qt and respective logos are trademarks of The Qt Company Ltd. in Finland and/or other countries worldwide. All other trademarks are property of their respective owners.]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>QMetaobject</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简易WinAPI注解]]></title>
    <url>%2F2019%2F02%2F18%2FWinAPI%2F%E7%AE%80%E6%98%93WinAPI%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[简易WinAPI注解GetWindowInfo例子：123WINDOWINFO winfo;winfo.cbSize = sizeof(winfo);GetWindowInfo(hWnd, &amp;winfo); 定义：123BOOL WINAPI GetWindowInfo( __in HWND hwnd, __inout PWINDOWINFO pwi); 作用：用于检索有关指定窗口的信息参数：12Hwnd 要检索信息的窗口的句柄。Pwi 指向一个接收信息的 PWINDOWINFO 结构，注意，在调用该函数之前必须设置 cbSize 成员为sizeof(WINDOWINFO)。 返回值：如果函数成功，则返回值为非零值。如果该函数失败，则返回值为零。要获取扩展的错误的信息，请调用GetLastError. GetClassNameA例子：12CHAR szBuff[256];GetClassNameA(hWnd, szBuff, sizeof(szBuff)/sizeof(CHAR)) 定义：1int GetClassName(HWND hWnd, LPTSTR IpClassName, int nMaxCount)； 参数：123hWnd：窗口的句柄及间接给出的窗口所属的类。IpClassName:指向接收窗口类名字符串的缓冲区的指针。nMaxCount：指定由参数lpClassName指示的缓冲区的字节数。如果类名字符串大于缓冲区的长度，则多出的部分被截断。 返回值：如果函数成功，返回值为拷贝到指定缓冲区的字符个数：如果函数失败，返回值为0。若想获得更多错误信息，请调用GetLastError函数。 GetWindowThreadProcessId例子：12DWORD nProcessID = 0;GetWindowThreadProcessId(hWnd, &amp;nProcessID); 定义：123DWORD GetWindowThreadProcessId( HWND hWnd, LPDWORD lpdwProcessId); 参数：12hWnd 向函数提供的）被查找窗口的句柄. (输入)lpdwProcessId 进程号的存放地址（变量地址）(输出) 作用：返回线程号，注意，lpdwProcessId 是存放进程号的变量。 GetCurrentProcessId例子：1GetCurrentProcessId() 定义:1DWORD WINAPI GetCurrentProcessId(VOID); 作用：获取当前进程的标示符(PID) IsWindow例子：1IsWindow(hWnd) 定义：1234WINUSERAPIBOOLWINAPIIsWindow(HWND hWnd); 参数：1hWnd 窗口的句柄 作用：判断句柄是不是一个已存在的窗口，存在返回非0，不存在返回0。 CreateMutex例子： 定义：12345HANDLE CreateMutex(LPSECURITY_ATTRIBUTE SlpMutexAttributes, // 指向安全属性的指针BOOL bInitialOwner, // 初始化互斥对象的所有者LPCTSTR lpName // 指向互斥对象名的指针); 参数：123lpMutexAttributes SECURITY_ATTRIBUTES，指定一个SECURITY_ATTRIBUTES结构，或传递零值（将参数声明为ByVal As Long，并传递零值），表示使用不允许继承的默认描述符bInitialOwner BOOL，如创建进程希望立即拥有互斥体，则设为TRUE。一个互斥体同时只能由一个线程拥有lpName String，指定互斥体对象的名字。用vbNullString创建一个未命名的互斥体对象。如已经存在拥有这个名字的一个事件，则打开现有的已命名互斥体。这个名字可能不与现有的事件、信号机、可等待计时器或文件映射相符 返回值：LONG，如执行成功，就返回互斥体对象的句柄；零表示出错。会设置GetLastError。如果返回的是一个有效句柄，但指定的名字已经存在，GetLastError也会设为ERROR_ALREADY_EXISTS，bInitialOwner的值将会被忽略。如果调用者限制了权限，GetLastError将会返回ERROR_ACCESS_DENIED，这个时候应该使用OpenMutex函数。 作用：创建一个互斥体（MUTEX），用于有独占要求的程序 (在其进程运行期间不允许其他使用此端口设备的程序运行，或不允许同名程序运行)。 OpenMutex定义：12345HANDLE OpenMutex(DWORD dwDesiredAccess, // accessBOOL bInheritHandle, // inheritance optionLPCTSTR lpName // object name); 参数：123456dwDesiredAccess：MUTEX_ALL_ACCESS 请求对互斥体的完全访问MUTEX_MODIFY_STATE 允许使用 ReleaseMutex 函数SYNCHRONIZE 允许互斥体对象同步使用bInheritHandle : 如希望子进程能够继承句柄，则为TRUElpName ：要打开对象的名字 返回值：如执行成功，返回对象的句柄；零表示失败。若想获得更多错误信息，请调用GetLastError函数。备注：一旦不再需要，注意一定要用 CloseHandle 关闭互斥体句柄。如对象的所有句柄都已关闭，那么对象也会删除 ReleaseMutex定义：123BOOL WINAPI ReleaseMutex(HANDLE hMutex); 参数：1hMutex：HANDLE，制定一个互斥体的句柄。 返回值:1BOOL，TRUE表示成功，FALSE表示失败。 作用：释放互斥对象的控制权。一个线程释放了互斥对象的控制权后，如果其他进程在等待互斥对象置位，则等待的线程可以得到该互斥对象，等待函数返回，互斥对象被新的线程所拥有。 CloseHandle定义：123BOOL CloseHandle(HANDLE hObject); 参数：1hObject ：代表一个已打开对象handle。 返回值：12TRUE：执行成功；FALSE：执行失败，可以调用GetLastError()获知失败原因。 作用：关闭一个内核对象。 其中包括文件、文件映射、进程、线程、安全和同步对象等。在CreateThread成功之后会返回一个hThread的handle，且内核对象的计数加1，CloseHandle之后，引用计数减1，当变为0时，系统删除内核对象。 若在线程执行完之后，没有调用CloseHandle，在进程执行期间，将会造成内核对象的泄露，相当于句柄泄露，但不同于内存泄露，这势必会对系统的效率带来一定程度上的负面影响。 但当进程结束退出后，系统会自动清理这些资源。 WaitForSingleObject定义：1234DWORD WINAPI WaitForSingleObject(__in HANDLE hHandle,__in DWORD dwMilliseconds); 参数： hHandle[in]对象句柄。可以指定一系列的对象，如Event、Job、Memory resource notification、Mutex、Process、Semaphore、Thread、Waitable timer等。 dwMilliseconds[in]定时时间间隔，单位为milliseconds（毫秒）。如果指定一个非零值，函数处于等待状态直到hHandle标记的对象被触发，或者时间到了。如果dwMilliseconds为0，对象没有被触发信号，函数不会进入一个等待状态，它总是立即返回。如果dwMilliseconds为INFINITE，对象被触发信号后，函数才会返回。 返回值：1234WAIT_ABANDONED 0x00000080 ： 当hHandle为mutex时，如果拥有mutex的线程在结束时没有释放核心对象会引发此返回值。WAIT_OBJECT_0 0x00000000 ： 指定的对象有信号WAIT_TIMEOUT 0x00000102 ： 等待超时WAIT_FAILED 0xFFFFFFFF ： 出现错误，可通过GetLastError得到错误代码]]></content>
      <categories>
        <category>WinAPI注解</category>
      </categories>
      <tags>
        <tag>WinAPI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简易EasyHook函数注解]]></title>
    <url>%2F2019%2F02%2F18%2F%E9%92%A9%E5%AD%90%2F%E7%AE%80%E6%98%93EasyHook%E5%87%BD%E6%95%B0%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[EasyHooK函数注释文件： easyhook.h插入钩子和使钩子失效，两个函数必须成对调用。先处理钩子，再使用钩子生效。 1、 插入钩子和去除钩子安装钩子安装钩子函数12345DRIVER_SHARED_API(NTSTATUS, LhInstallHook( void* InEntryPoint, //真实API，如CreateFile void* InHookProc, //钩子函数，如MyCreateFile void* InCallback, //回调函数，一般设置为NULL TRACED_HOOK_HANDLE OutHandle)); //返回句柄，该句柄以链表方式记录钩子信息，内部结构内容非常多。 去除钩子卸载钩子（并不还原，只是禁用）123DRIVER_SHARED_API(NTSTATUS, LhUninstallAllHooks());DRIVER_SHARED_API(NTSTATUS, LhUninstallHook( TRACED_HOOK_HANDLE InHandle)); //由LhInstallHook的第4个参数返回。 等待移除删除钩子（还原）12DRIVER_SHARED_API(NTSTATUS, LhWaitForPendingRemovals());等待内存移除 2、 使用钩子生效设置包含ACL（access control list），1234EASYHOOK_NT_EXPORT LhSetInclusiveACL( ULONG* InThreadIdList, //定义为一个数组如ULONG HookCreateFileW_ACLEntries[1] = &#123;0&#125;; ULONG InThreadCount, //一般设置为1 TRACED_HOOK_HANDLE InHandle); //由LhInstallHook的第4个参数返回 设置排除ACL（access control list），1234567891011121314151617EASYHOOK_NT_EXPORT LhSetExclusiveACL( ULONG* InThreadIdList, //定义为一个数组如ULONG HookCreateFileW_ACLEntries[1] = &#123;0&#125;; ULONG InThreadCount, //一般设置为1 TRACED_HOOK_HANDLE InHandle); //由LhInstallHook的第4个参数返回EASYHOOK_NT_EXPORT LhSetGlobalInclusiveACL( ULONG* InThreadIdList, //定义为一个数组如ULONG HookCreateFileW_ACLEntries[1] = &#123;0&#125;; ULONG InThreadCount); //一般设置为1EASYHOOK_NT_EXPORT LhSetGlobalExclusiveACL( ULONG* InThreadIdList, //定义为一个数组如ULONG HookCreateFileW_ACLEntries[1] = &#123;0&#125;; ULONG InThreadCount); //一般设置为1EASYHOOK_NT_EXPORT LhIsThreadIntercepted( TRACED_HOOK_HANDLE InHook, //由LhInstallHook的第4个参数返回 ULONG InThreadID, BOOL* OutResult); 3、句柄定义123456typedef struct _LOCAL_HOOK_INFO_* PLOCAL_HOOK_INFO;typedef struct _HOOK_TRACE_INFO_&#123; PLOCAL_HOOK_INFO Link;&#125;HOOK_TRACE_INFO, *TRACED_HOOK_HANDLE; 所使用到的关键数据结构为LOCAL_HOOK_INFO结构体:]]></content>
      <categories>
        <category>钩子</category>
      </categories>
      <tags>
        <tag>EasyHooK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冯·诺依曼计算机]]></title>
    <url>%2F2019%2F02%2F13%2F%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%2F%E5%86%AF%C2%B7%E8%AF%BA%E4%BE%9D%E6%9B%BC%E8%AE%A1%E7%AE%97%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[冯·诺依曼计算机冯·诺依曼（VonNeumann）计算机是现代计算机的基础，往前追溯为图灵计算机。冯·诺依曼计算机的实现思路为：存储程序控制 ；存储程序控制的提出和实现也是冯·诺依曼对计算机世界的最大贡献。 存储程序控制 1.计算机（指硬件）应由运算器、存储器、控制器、输入设备和输出设备五大基本部件组成2.计算机内部采用二级制来表示指令和数据3.将编好的程序和原始数据事先存入存储器中，然后再启动计算机工作。 冯·诺依曼结构Main Memory : 主存CPU :&emsp;&emsp;&emsp;ArithmeticLogic Unit : 算术逻辑单元（运算器）&emsp;&emsp;&emsp;Program Control Unit : 程序控制单元（控制器）I/O Equipment:&emsp;&emsp;&emsp;输入/输出设备 新和旧的区别：I/O设备挂载的位置 1、原始结构图原始的 冯·诺依曼计算机 以运算器为中心： 2、新结构图新的 冯·诺依曼计算机 以存储器为中心： 3、硬件说明 控制器 是分析和执行指令的部件，也是统一指挥并控制计算机各部件协调工作的中心部件，所依据的是机器指令。① 程序计数器 PC：存储下一条要执行指令的地址；② 指令寄存器 IR：存储即将执行的指令；③ 指令译码器 ID：对指令中的操作码字段进行分析解释；④ 时序部件：提供时序控制信号 运算器 也称为算术逻辑单元（ ArithmeticandLogicUnit， ALU），其主要功能是在控制器的控制下完成各种算术运算和逻辑运算。① 算术逻辑单元 ALU：数据的算术运算和逻辑运算；② 累加寄存器 AC：通用寄存器，为 ALU 提供一个工作区，用在暂存数据；③ 数据缓冲寄存器 DR：写内存时，暂存指令或数据；④ 状态条件寄存器 PSW：存状态标志与控制标志（争议点：也有将其归为控制器的）。 主存储器也称为内存储器（通常简称为“内存”或“主存”）。存储现场操作的信息与中间结果，包括机器指令和数据。 辅助存储器也称为外存储器，通常简称为外存或辅存。存储需要长期保存的各种信息。 输入设备的任务是把人们编好的程序和原始数据送到计算机中去，并且将它们转换成计算机内部所能识别和接受的信息方式。按输入信息的形态可分为字符（包括汉字）输入、图形输入、图像输入及语音输入等。目前，常见的输入设备有键盘、 鼠标、扫描仪等。 输出设备的任务是将计算机的处理结果以人或其他设备所能接受的形式送出计算机。目前，最常用的输出设备是打印机和显示器。有些设备既可以是输入设备，同时也可以是输出设备，例如，辅助存储器、自动控制和检测系统中使用的数模转换装置等。 指令定义：程序控制逻辑，由控制器分析和执行。 复杂指令（Complex Instruction Set Computer， CISC）思路：增强指令的功能，设置一些功能复杂的指令，把一些原来由软件实现的、常用的功能改用硬件的指令系统来实现。 特点 （1）指令数量众多。指令系统拥有大量的指令，通常有 100～250 条。 （2）指令使用频率相差悬殊。最常使用的是一些比较简单的指令，仅占指令总数的 20%，但在程序中出现的频率却占 80%。而大部分复杂指令却很少使用。 （3）支持很多种寻址方式。支持的寻址方式通常为 5～20 种。 （4）变长的指令。指令长度不是固定的，变长的指令增加指令译码电路的复杂性。 （5）指令可以对主存单元中的数据直接进行处理。典型的 CISC 通常都有指令能够直接对主存单元中的数据进行处理，其执行速度较慢。 （6）以微程序控制为主。 CISC 的指令系统很复杂，难以用硬布线逻辑（组合逻辑）电路实现控制器，通常采用微程序控制 精简指令（Reduced Instruction Set Computer， RISC）思路：简化指令功能，只保留那些功能简单，能在一个节拍内执行完成指令，较复杂的功能用一段子程序来实现。 特点 （1）指令数量少。优先选取使用频率最高的一些简单指令和一些常用指令，避免使用复杂指令。 只提供了 LOAD（从存储器中读数）和 STORE（把数据写入存储器）两条指令对存储器操作，其余所有的操作都在 CPU 的寄存器之间进行。 （2）指令的寻址方式少。通常只支持寄存器寻址方式、立即数寻址方式和相对寻址方式。 （ 3）指令长度固定，指令格式种类少。因为 RISC 指令数量少、格式少、相对简单，其指令长度固定，指令之间各字段的划分比较一致，译码相对容易。 （4）以硬布线逻辑控制为主。为了提高操作的执行速度，通常采用硬布线逻辑（组合逻辑）来构建控制器。 （5）单周期指令执行，采用流水线技术。因为简化了指令系统，很容易利用流水线技术，使得大部分指令都能在一个机器周期内完成。少数指令可能会需要多周期，例如，OAD/STORE 指令因为需要访问存储器，其执行时间就会长一些。 （6）优化的编译器： RISC 的精简指令集使编译工作简单化。因为指令长度固定、格式少、寻址方式少，编译时不必在具有相似功能的许多指令中进行选择，也不必为寻址方式的选择而费心，同时易于实现优化，从而可以生成高效率执行的机器代码。 （7）CPU 中的通用寄存器数量多，一般在 32 个以上，有的可达上千个。 Flynn分类法1966年，Michael.J.Flynn提出。根据指令流和数据流的多倍性对计算机系统进行分类。 指令流：指机器执行的指令序列；数据流：指由指令流调用的数据序列，包括输入数据和中间结果，但不包括输出数据。 分类1、单指令单数据流（Single Instruction stream and Single Data stream）：SISD 传统的顺序执行的单处理器计算机，其指令部件每次只对一条指令进行译码，并只对一个操作部件分配数据。 2、单指令多数据流（Single Instruction stream and Multiple Data stream）：SIMD 并行处理机（矩阵处理机）为代表，并行处理机包括多个重复的处理单元，由单一指令部件控制，按照同一指令流的要求为它们分配各自所需的不同数据。 3、多指令单数据流（Multiple Instruction stream and Single Data stream）：MISD 具有 n 个处理单元，按 n 条不同指令的要求对同一数据流及其中间结果进行不同的处理。一个处理单元的输出又作为另一个处理单元的输入。这类系统实际上很少见到。有文献把流水线看作多个指令部件，称流水线计算机是 MISD。 4、多指令多数据流（Multiple Instruction stream and Multiple Data stream）：MIMD 能实现作业、任务、指令等各级全面并行的多机系统。如多核处理器、多处理机属于 MIMD。 总线定义一组能为多个部件 分时 共享 的公共信息传送线路。分时： 同一时刻只允许有一个部件向总线发送信息共享： 总线上可以挂接多个部件，各个部件之间相互交换的信息都可以通过这组公共线路传送 分类按功能： 地址总线：传递地址信息，地址总线的个数为n，则需要n位二进制数来表示所有的地址。 数据总线：传递数据信息，数据总线的长度为n，计算机一次处理n位数据。 控制总线：传递控制信号 p.s. 地址总线和数据总线的位数不一定相同 一个字的位数为数据总线的位数 按位置： 内部总线：CPU内部，寄存器之间和算术逻辑部件ALU与控制部件之间传输数据的总线 外部总线：CPU与内存RAM、ROM和I/O设备接口之间通性的通路 ps：RAM：RamdomAccessMemory &emsp;随机存储器,主存ROM：Read Only Memory &emsp;&emsp;&emsp;只读存储器, BIOS]]></content>
      <categories>
        <category>系统工程师考试归纳</category>
      </categories>
      <tags>
        <tag>计算机原理</tag>
        <tag>冯·诺依曼</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo配合GitHub建个人博客]]></title>
    <url>%2F2019%2F02%2F12%2FHexo%E7%9A%84%E4%BD%BF%E7%94%A8%2FHexo%E9%85%8D%E5%90%88gitHub%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Hexo配合GitHub创建个人博客环境说明系统： Windows10企业版 Hexo 安装Hexo是基于Node.js开发的，所以需要先安装Node.js。 Hexo是一个轻量级的Node.js博客框架，由一位台湾的在校大学生开发完成！ 安装node.js博主的系统为Windows10，只需要现在对应的版本安装即可：Node.js下载后缀名为.msi的安装包，可以直接双击安装。 安装Hexo安装完Node.js后，可以使用命令安装Hexo：1npm install -g hexo-cli 卸载Hexo：1npm uninstall hexo-cli 卸载需要定位到对应文件夹 Hexo 配置安装完Hexo后，要使用Hexo，则在指定的文件夹中新建文件：123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 新建完成后的文档结构： 配置简单本地搜索安装插件1npm install hexo-generator-searchdb --save 插件推荐 插件 用途 hexo-all-minifier css,js,html等的压缩 hexo-autonofollow 自动对外部链接增加nofollow属性 hexo-generator-sitemap 生成sitemap hexo-generator-baidu-sitemap 生成百度sitemap hexo-prism-plugin 代码高亮 hexo-math 数学公式 修改站点_config.yml文件12345search: path: search.xml field: post format: html limit: 10000 修改主题_config.yml文件12local_search: enable: true GitHub 配置 Next主题配置]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHubPage</tag>
      </tags>
  </entry>
</search>
